

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tnetwork.dyn_community.communities_dyn_sn &mdash; tnetwork  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> tnetwork
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html#who-uses-tnetwork">Who uses tnetwork?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html#goals">Goals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html#free-software">Free software</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../installing.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installing.html#quick-install">Quick install</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installing.html#installing-from-source">Installing from source</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../installing.html#github">GitHub</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../installing.html#requirements">Requirements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../installing.html#python">Python</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/dyn_communities.html">Dynamic Communities Classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/dyn_communities.html#sequences-of-snapshots-snapshot-communities">Sequences of snapshots snapshot_communities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_communities.html#adding-and-removing-snapshot-affiliations">Adding and removing snapshot_affiliations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesSN.add_affiliation.html">tnetwork.DynCommunitiesSN.add_affiliation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesSN.add_community.html">tnetwork.DynCommunitiesSN.add_community</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesSN.set_communities.html">tnetwork.DynCommunitiesSN.set_communities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_communities.html#accessing-snapshot-affiliations">Accessing snapshot_affiliations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesSN.affiliations.html">tnetwork.DynCommunitiesSN.affiliations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesSN.communities.html">tnetwork.DynCommunitiesSN.communities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesSN.snapshot_affiliations.html">tnetwork.DynCommunitiesSN.snapshot_affiliations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesSN.snapshot_communities.html">tnetwork.DynCommunitiesSN.snapshot_communities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesSN.affiliations_durations.html">tnetwork.DynCommunitiesSN.affiliations_durations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_communities.html#converting">Converting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesSN.to_DynCommunitiesIG.html">tnetwork.DynCommunitiesSN.to_DynCommunitiesIG</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/dyn_communities.html#interval-graph-snapshot-communities">Interval graph snapshot_communities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_communities.html#id1">Adding and removing snapshot_affiliations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesIG.add_affiliation.html">tnetwork.DynCommunitiesIG.add_affiliation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesIG.add_affiliations_from.html">tnetwork.DynCommunitiesIG.add_affiliations_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesIG.remove_affiliation.html">tnetwork.DynCommunitiesIG.remove_affiliation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_communities.html#id2">Accessing snapshot_affiliations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesIG.affiliations.html">tnetwork.DynCommunitiesIG.affiliations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesIG.communities.html">tnetwork.DynCommunitiesIG.communities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesIG.affiliations_durations.html">tnetwork.DynCommunitiesIG.affiliations_durations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_communities.html#other-functions">Other functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesIG.nodes_main_com.html">tnetwork.DynCommunitiesIG.nodes_main_com</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesIG.nodes_natural_order.html">tnetwork.DynCommunitiesIG.nodes_natural_order</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynCommunitiesIG.nodes_ordered_by_com.html">tnetwork.DynCommunitiesIG.nodes_ordered_by_com</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/readwrite.html">Read/Write</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/readwrite.html#simple-example">Simple example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/readwrite.html#read-write-graphs">Read/Write graphs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/readwrite.html#read-write-snapshot-graphs">Read/Write snapshot graphs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/iof/tnetwork.write_snapshots.html">tnetwork.write_snapshots</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/iof/tnetwork.read_snapshots.html">tnetwork.read_snapshots</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/iof/tnetwork.read_graph_link_stream.html">tnetwork.read_graph_link_stream</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/readwrite.html#read-write-interval-graphs">Read/Write interval graphs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/iof/tnetwork.write_IG.html">tnetwork.write_IG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/iof/tnetwork.write_ordered_changes.html">tnetwork.write_ordered_changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/iof/tnetwork.read_IG.html">tnetwork.read_IG</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/readwrite.html#read-write-communities">Read/Write Communities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/readwrite.html#read-write-snapshot-snapshot-affiliations">Read/Write snapshot snapshot_affiliations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/iof/tnetwork.write_com_SN.html">tnetwork.write_com_SN</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/iof/tnetwork.read_SN_by_com.html">tnetwork.read_SN_by_com</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/readwrite.html#read-write-interval-graph-snapshot-affiliations">Read/Write interval graph snapshot_affiliations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/iof/tnetwork.write_IGC.html">tnetwork.write_IGC</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/dyn_graph.html">Dynamic Network Classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/dyn_graph.html#sequences-of-snapshots">Sequences of snapshots</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_graph.html#adding-and-removing-nodes-and-edges">Adding and removing nodes and edges</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.add_node_presence.html">tnetwork.DynGraphSN.add_node_presence</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.add_nodes_presence_from.html">tnetwork.DynGraphSN.add_nodes_presence_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.add_interaction.html">tnetwork.DynGraphSN.add_interaction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.add_interactions_from.html">tnetwork.DynGraphSN.add_interactions_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.remove_node_presence.html">tnetwork.DynGraphSN.remove_node_presence</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.remove_interaction.html">tnetwork.DynGraphSN.remove_interaction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.remove_interactions_from.html">tnetwork.DynGraphSN.remove_interactions_from</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_graph.html#accessing-the-graph">Accessing the graph</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.node_presence.html">tnetwork.DynGraphSN.node_presence</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.graph_at_time.html">tnetwork.DynGraphSN.graph_at_time</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.snapshots_timesteps.html">tnetwork.DynGraphSN.snapshots_timesteps</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.last_snapshot.html">tnetwork.DynGraphSN.last_snapshot</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_graph.html#conversion-to-different-formats">Conversion to different formats</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.to_DynGraphIG.html">tnetwork.DynGraphSN.to_DynGraphIG</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.to_tensor.html">tnetwork.DynGraphSN.to_tensor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_graph.html#aggregation">Aggregation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.cumulated_graph.html">tnetwork.DynGraphSN.cumulated_graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.aggregate_sliding_window.html">tnetwork.DynGraphSN.aggregate_sliding_window</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.aggregate_time_period.html">tnetwork.DynGraphSN.aggregate_time_period</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_graph.html#other-graph-operations">Other graph operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphSN.apply_nx_function.html">tnetwork.DynGraphSN.apply_nx_function</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/dyn_graph.html#interval-graphs">Interval graphs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_graph.html#id1">Adding and removing nodes and edges</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphIG.add_node_presence.html">tnetwork.DynGraphIG.add_node_presence</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphIG.add_nodes_presence_from.html">tnetwork.DynGraphIG.add_nodes_presence_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphIG.add_interaction.html">tnetwork.DynGraphIG.add_interaction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphIG.add_interactions_from.html">tnetwork.DynGraphIG.add_interactions_from</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_graph.html#id2">Accessing the graph</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphIG.node_presence.html">tnetwork.DynGraphIG.node_presence</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphIG.graph_at_time.html">tnetwork.DynGraphIG.graph_at_time</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphIG.interactions.html">tnetwork.DynGraphIG.interactions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphIG.change_times.html">tnetwork.DynGraphIG.change_times</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_graph.html#id3">Conversion to different formats</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphIG.to_DynGraphSN.html">tnetwork.DynGraphIG.to_DynGraphSN</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/dyn_graph.html#id4">Aggregation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../reference/generated/tnetwork.DynGraphIG.cumulated_graph.html">tnetwork.DynGraphIG.cumulated_graph</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/Intervals.html">Intervals Class</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/Intervals.html#adding-and-removing-intervals">Adding and removing intervals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.__init__.html">tnetwork.utils.Intervals.__init__</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.add_interval.html">tnetwork.utils.Intervals.add_interval</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.__add__.html">tnetwork.utils.Intervals.__add__</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.__sub__.html">tnetwork.utils.Intervals.__sub__</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/Intervals.html#accessing-intervals-properties">Accessing Intervals properties</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.contains_t.html">tnetwork.utils.Intervals.contains_t</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.contains.html">tnetwork.utils.Intervals.contains</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.__contains__.html">tnetwork.utils.Intervals.__contains__</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.periods.html">tnetwork.utils.Intervals.periods</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.duration.html">tnetwork.utils.Intervals.duration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.start.html">tnetwork.utils.Intervals.start</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.end.html">tnetwork.utils.Intervals.end</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/Intervals.html#operations">Operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.intersection.html">tnetwork.utils.Intervals.intersection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.union.html">tnetwork.utils.Intervals.union</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../reference/generated/tnetwork.utils.Intervals.__eq__.html">tnetwork.utils.Intervals.__eq__</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/DCD.html">Dynamic Community Detection</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/generated/tnetwork.iterative_match.html">tnetwork.iterative_match</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/generated/tnetwork.match_survival_graph.html">tnetwork.match_survival_graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/generated/tnetwork.rollingCPM.html">tnetwork.rollingCPM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/generated/tnetwork.track_communities.html">tnetwork.track_communities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/generated/tnetwork.generate_multi_temporal_scale.html">tnetwork.generate_multi_temporal_scale</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/vizu.html">Visualization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/generated/tnetwork.plot_as_graph.html">tnetwork.plot_as_graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/generated/tnetwork.plot_longitudinal.html">tnetwork.plot_longitudinal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/generated/tnetwork.plot_longitudinal_sn_clusters.html">tnetwork.plot_longitudinal_sn_clusters</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/generation.html">Generation</a><ul class="simple">
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">tnetwork</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>tnetwork.dyn_community.communities_dyn_sn</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tnetwork.dyn_community.communities_dyn_sn</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">sortedcontainers</span>
<span class="kn">from</span> <span class="nn">tnetwork.dyn_community.communitiesEventsHandler</span> <span class="kn">import</span> <span class="n">CommunitiesEvent</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">tnetwork</span> <span class="k">as</span> <span class="nn">tn</span>
<span class="c1">#from tnetwork.utils import bidict #### do not use bidict to avoid having to use frozenset</span>
<span class="kn">from</span> <span class="nn">tnetwork.utils.community_utils</span> <span class="kn">import</span> <span class="n">nodesets2affiliations</span>
<span class="kn">import</span> <span class="nn">statistics</span>
<span class="kn">from</span> <span class="nn">tnetwork.utils.community_utils</span> <span class="kn">import</span> <span class="n">jaccard</span>
<span class="kn">from</span> <span class="nn">tnetwork.utils.intervals</span> <span class="kn">import</span> <span class="n">Intervals</span>
<span class="kn">from</span> <span class="nn">tnetwork.dyn_community.communities_dyn</span> <span class="kn">import</span> <span class="n">DynCommunities</span>


<div class="viewcode-block" id="DynCommunitiesSN"><a class="viewcode-back" href="../../../reference/dyn_communities.html#tnetwork.DynCommunitiesSN">[docs]</a><span class="k">class</span> <span class="nc">DynCommunitiesSN</span><span class="p">(</span><span class="n">DynCommunities</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dynamic snapshot_affiliations as sequences of snapshot_affiliations</span>

<span class="sd">    Communities are represented as a SortedDict, key:time, value: dict id:{set of nodes}</span>
<span class="sd">    -----------TODO</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">snapshots</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization</span>

<span class="sd">        Initialize a dynamic community object, corresponding to a snapshot-based dynamic network</span>

<span class="sd">        :param snapshots: list of snapshots timestep to create, initially empty</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="o">=</span><span class="n">sortedcontainers</span><span class="o">.</span><span class="n">SortedDict</span><span class="p">()</span> <span class="c1">#sorteddict t:{id:{set of nodes}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">CommunitiesEvent</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_automaticID</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">snapshots</span><span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">snapshots</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_empty_snapshot</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_empty_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>

    <span class="k">def</span> <span class="nf">remove_communities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">communities</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">com</span> <span class="ow">in</span> <span class="n">communities</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">com</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">time</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">time</span><span class="p">][</span><span class="n">com</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keep only the selected period</span>

<span class="sd">        :param start:</span>
<span class="sd">        :param end:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">to_return</span> <span class="o">=</span> <span class="n">tn</span><span class="o">.</span><span class="n">DynCommunitiesSN</span><span class="p">()</span>
        <span class="n">interv</span> <span class="o">=</span> <span class="n">tn</span><span class="o">.</span><span class="n">Intervals</span><span class="p">((</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">interv</span><span class="p">:</span>
                <span class="n">to_return</span><span class="o">.</span><span class="n">set_communities</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_return</span>


<div class="viewcode-block" id="DynCommunitiesSN.snapshot_communities"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.snapshot_communities.html#tnetwork.DynCommunitiesSN.snapshot_communities">[docs]</a>    <span class="k">def</span> <span class="nf">snapshot_communities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Affiliations by snapshot_communities</span>

<span class="sd">        If t is given, return affiliation at this t as a bidict id:{set of nodes}</span>
<span class="sd">        else, return a sorted dict, key:time, value: dict id:{set of nodes}</span>

<span class="sd">        :param t: time</span>
<span class="sd">        :return: a dict id:{set of nodes}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">communities_sn_by_sn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Communities snapshots by snapshots</span>

<span class="sd">        Return for each community its nodes snaphsot by snapshot</span>
<span class="sd">        :return: a dict c:{SortedDict{t:{set of nodes}}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_return</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cID</span><span class="p">,</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">to_return</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cID</span><span class="p">,</span><span class="n">sortedcontainers</span><span class="o">.</span><span class="n">SortedDict</span><span class="p">())</span>
                <span class="n">to_return</span><span class="p">[</span><span class="n">cID</span><span class="p">][</span><span class="n">time</span><span class="p">]</span><span class="o">=</span><span class="n">nodes</span>
        <span class="k">return</span> <span class="n">to_return</span>

<div class="viewcode-block" id="DynCommunitiesSN.communities"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.communities.html#tnetwork.DynCommunitiesSN.communities">[docs]</a>    <span class="k">def</span> <span class="nf">communities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Communities</span>

<span class="sd">        If t is given, return affiliation at this t as a dict, key=node, value=set of snapshot_communities</span>
<span class="sd">        else, return a dict, key:node, value: dict community:list of times</span>

<span class="sd">        :param t: time</span>
<span class="sd">        :return: dictionary, key=node, value=dict community:list of times or if t is not None: dict community:list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">to_return</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">cID</span><span class="p">,</span><span class="n">nodes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                        <span class="n">to_return</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cID</span><span class="p">,{})</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="n">cID</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">n</span><span class="p">,[])</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="n">cID</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">to_return</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span></div>

<div class="viewcode-block" id="DynCommunitiesSN.affiliations"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.affiliations.html#tnetwork.DynCommunitiesSN.affiliations">[docs]</a>    <span class="k">def</span> <span class="nf">affiliations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Affiliations by nodes</span>

<span class="sd">        If t is given, return affiliation at this t as a dict, key=node, value=set of snapshot_communities</span>
<span class="sd">        else, return a dict, key:node, value: dict community:list of times</span>

<span class="sd">        :param t: time</span>
<span class="sd">        :return: dictionary, key=node, value=dict community:list of times or if t is not None: dict community:list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">to_return</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">cID</span><span class="p">,</span><span class="n">nodes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                        <span class="n">to_return</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">n</span><span class="p">,{})</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cID</span><span class="p">,[])</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">cID</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">to_return</span>


        <span class="k">return</span> <span class="n">nodesets2affiliations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()[</span><span class="n">t</span><span class="p">])</span></div>


<div class="viewcode-block" id="DynCommunitiesSN.affiliations_durations"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.affiliations_durations.html#tnetwork.DynCommunitiesSN.affiliations_durations">[docs]</a>    <span class="k">def</span> <span class="nf">affiliations_durations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">communities</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Durations of snapshot_affiliations</span>

<span class="sd">        Return the duration in each community (for non-zero values) for the provided nodes and the provided snapshot_affiliations (default: all)</span>
<span class="sd">        return set of triplets (n,c,duration), or set of pairs of one if the parameters has a single value, or a single value if single node and single com</span>

<span class="sd">        :param nodes: node(s) for which we want durations. single node or set of nodes</span>
<span class="sd">        :param communities: snapshot_communities(s) for which we want durations. single community or set of snapshot_communities</span>
<span class="sd">        :return: set of triplets (n,c,duration), or set of pairs of one if the parameters has a single value, or a single value if single node and single com</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">toReturn</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">aff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affiliations</span><span class="p">()</span>
        <span class="n">coms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">communities</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nodes</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">aff</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">communities</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">communities</span><span class="o">=</span><span class="n">coms</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="n">nodes</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">communities</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="n">communities</span><span class="o">=</span><span class="p">[</span><span class="n">communities</span><span class="p">]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">communities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">communities</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">communities</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">aff</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">toReturn</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">)]</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">aff</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">communities</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">toReturn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">toReturn</span><span class="o">.</span><span class="n">items</span><span class="p">())[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">toReturn</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span><span class="n">t</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">),</span><span class="n">t</span> <span class="ow">in</span> <span class="n">toReturn</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">communities</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">toReturn</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span><span class="n">t</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">),</span><span class="n">t</span> <span class="ow">in</span> <span class="n">toReturn</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">return</span> <span class="n">toReturn</span></div>

<div class="viewcode-block" id="DynCommunitiesSN.snapshot_affiliations"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.snapshot_affiliations.html#tnetwork.DynCommunitiesSN.snapshot_affiliations">[docs]</a>    <span class="k">def</span> <span class="nf">snapshot_affiliations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Affiliations by nodes</span>

<span class="sd">        If t is given, return affiliation at this t as a dict, key=node, value=set of snapshot_communities</span>
<span class="sd">        else, return a sorted dict, key:time, value: dict node:snapshot_communities</span>

<span class="sd">        :param t: time</span>
<span class="sd">        :return: sorted dict, key:time, value: dict node:snapshot_communities or key=node, value=set of snapshot_communities</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sortedcontainers</span><span class="o">.</span><span class="n">SortedDict</span><span class="p">({</span><span class="n">k</span><span class="p">:</span><span class="n">nodesets2affiliations</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">nodesets2affiliations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()[</span><span class="n">t</span><span class="p">])</span></div>

<div class="viewcode-block" id="DynCommunitiesSN.add_affiliation"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.add_affiliation.html#tnetwork.DynCommunitiesSN.add_affiliation">[docs]</a>    <span class="k">def</span> <span class="nf">add_affiliation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">cIDs</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Affiliate node(s) to community(ies) at time(s)</span>

<span class="sd">        Add belonging for the provided node(s) to the provided communitie(s) at the provided time(s).</span>
<span class="sd">        (all nodes, at all times, in all snapshot_affiliations)</span>
<span class="sd">        If snapshot_affiliations do not exist, they are created.</span>

<span class="sd">        :param nodes: accept set/list of nodes or single node</span>
<span class="sd">        :param times: accept list of times or single time</span>
<span class="sd">        :param cIDs: accept lists of coms or single com</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">times</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">times</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cIDs</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cIDs</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">cIDs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">cIDs</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">nodes</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">nodes</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>



        <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">ts</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
            <span class="n">coms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">ts</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">cIDs</span><span class="p">:</span>
                <span class="n">cs</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">coms</span><span class="p">:</span>
                    <span class="n">coms</span><span class="p">[</span><span class="n">cs</span><span class="p">]</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>
                <span class="n">coms</span><span class="p">[</span><span class="n">cs</span><span class="p">]</span><span class="o">=</span><span class="n">coms</span><span class="p">[</span><span class="n">cs</span><span class="p">]</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="DynCommunitiesSN.set_communities"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.set_communities.html#tnetwork.DynCommunitiesSN.set_communities">[docs]</a>    <span class="k">def</span> <span class="nf">set_communities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">communities</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Affiliate nodes given a dictionary representation</span>

<span class="sd">        Given a clustering provided as a dict  id:{set of nodes} , set this clustering at the</span>
<span class="sd">        provided time (replace any existing clustering at that time)</span>

<span class="sd">        :param clusters: dict or bidict{id:frozenset of nodes}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">communities</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">communities</span></div>

<div class="viewcode-block" id="DynCommunitiesSN.add_community"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.add_community.html#tnetwork.DynCommunitiesSN.add_community">[docs]</a>    <span class="k">def</span> <span class="nf">add_community</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a community at a time</span>

<span class="sd">        Create a community at time t with the provided nodes and id  ( random id if not provided)</span>

<span class="sd">        :param t: time</span>
<span class="sd">        :param nodes: a community provided as a set/list of nodes</span>
<span class="sd">        :param id: optional id, otherwise, new unique one</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">id</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="nb">id</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_automaticID</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_automaticID</span><span class="o">+=</span><span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_affiliation</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">id</span></div>

    <span class="k">def</span> <span class="nf">_com_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the id of a community at a time</span>
<span class="sd">        </span>
<span class="sd">        given a set of nodes composing a community, return the id of this community. If there is not one and only </span>
<span class="sd">        one community containing those nodes, raise an exception</span>

<span class="sd">        :param t: time</span>
<span class="sd">        :param nodes: set of nodes</span>
<span class="sd">        :return: ID of the community. If several matching, raise exceptions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_return</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">com_nodes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">com_nodes</span><span class="o">==</span><span class="n">nodes</span><span class="p">:</span>
                <span class="n">to_return</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_return</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;no community found&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_return</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;several matching snapshot_communities found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_return</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>



    <span class="k">def</span> <span class="nf">_compute_fraction_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">com1</span><span class="p">,</span> <span class="n">com2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        compute a fraction of identity between two snapshot_affiliations</span>

<span class="sd">        :param com1: a com</span>
<span class="sd">        :param com2: another com</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">common</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">com1</span> <span class="o">&amp;</span> <span class="n">com2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">common</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">com1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">common</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">com2</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">create_standard_event_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keepingPreviousEvents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span><span class="n">score</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From a set of static snapshot_affiliations, do a standard matching process such as all snapshot_affiliations in consecutive steps with at least a node in common are linked by an event, and compute a similarity score</span>

<span class="sd">        :param keepingPreviousEvents: if true, if events were already present, we keep them and compute their score</span>
<span class="sd">        :param threshold: a minimal value of score under which a link is not created. Default: 0</span>
<span class="sd">        :param score: a function describing how to compute the score. Takes 2 snapshot_affiliations as input and return the score.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">score</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">jaccard</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keepingPreviousEvents</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">CommunitiesEvent</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">communities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()</span>
            <span class="k">for</span> <span class="p">((</span><span class="n">t1</span><span class="p">,</span><span class="n">com1</span><span class="p">),(</span><span class="n">t2</span><span class="p">,</span><span class="n">com2</span><span class="p">))</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                <span class="n">fraction</span> <span class="o">=</span> <span class="n">score</span><span class="p">(</span><span class="n">communities</span><span class="p">[</span><span class="n">t1</span><span class="p">][</span><span class="n">com1</span><span class="p">],</span> <span class="n">communities</span><span class="p">[</span><span class="n">t2</span><span class="p">][</span><span class="n">com2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[(</span><span class="n">t1</span><span class="p">,</span> <span class="n">com1</span><span class="p">)][(</span><span class="n">t2</span><span class="p">,</span> <span class="n">com2</span><span class="p">)][</span><span class="s2">&quot;fraction&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">fraction</span>

        <span class="c1">#compute events between consecutive snapshot_affiliations</span>
        <span class="n">communities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">communities</span><span class="p">),</span><span class="mi">1</span><span class="p">):</span>
            <span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">comsBefore</span><span class="p">)</span> <span class="o">=</span> <span class="n">communities</span><span class="o">.</span><span class="n">peekitem</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">(</span><span class="n">t2</span><span class="p">,</span><span class="n">comsPresent</span><span class="p">)</span> <span class="o">=</span> <span class="n">communities</span><span class="o">.</span><span class="n">peekitem</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">comID</span><span class="p">,</span><span class="n">comNodes</span> <span class="ow">in</span> <span class="n">comsBefore</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">com2ID</span><span class="p">,</span><span class="n">com2Nodes</span> <span class="ow">in</span> <span class="n">comsPresent</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">fraction</span> <span class="o">=</span> <span class="n">score</span><span class="p">(</span><span class="n">comNodes</span><span class="p">,</span> <span class="n">com2Nodes</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">fraction</span><span class="o">&gt;</span><span class="n">threshold</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">add_event</span><span class="p">((</span><span class="n">t1</span><span class="p">,</span> <span class="n">comID</span><span class="p">),</span> <span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">com2ID</span><span class="p">),</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s2">&quot;unknown&quot;</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="n">fraction</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_change_com_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">oldID</span><span class="p">,</span><span class="n">newID</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify the ID of a community, in the community list and the event graph</span>

<span class="sd">        :param t:</span>
<span class="sd">        :param nodes:</span>
<span class="sd">        :param newID:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nodesOfCom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">oldID</span><span class="p">]</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">oldID</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">newID</span><span class="p">]</span><span class="o">=</span><span class="n">nodesOfCom</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">oldID</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">,</span> <span class="p">{(</span><span class="n">t</span><span class="p">,</span><span class="n">oldID</span><span class="p">):</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">newID</span><span class="p">)},</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_relabel_communities_to_avoid_conflict_between_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_change_com_id</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="nb">id</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_relabel_coms_from_continue_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typedEvents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        If an event graph is present, rename the communities such as two communities that are linked by an event labeled &quot;continue&quot; will have the same ID.</span>
<span class="sd">        If events are not labeled, is possible to label them automatically into merge, split and continue using the in/out degrees of nodes in the event graph</span>

<span class="sd">        Be careful that if your communities in different snapshots already have similar names, it can add confusion</span>
<span class="sd">        :param typedEvents: True if continue labels have already been set.</span>
<span class="sd">        :param rename: True if all communities are renamed. This is useful if, before calling this function, two communities in different steps could have the same name, and we do not want to keep this information</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">rename</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_relabel_communities_to_avoid_conflict_between_steps</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">typedEvents</span><span class="p">:</span>
            <span class="n">changedIDs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;continue&quot;</span><span class="p">:</span>

                    <span class="c1">#update com ID in self</span>
                    <span class="n">timeEnd</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">idComToChange</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">idComToKeep</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">changedIDs</span><span class="p">:</span>
                        <span class="n">idComToKeep</span> <span class="o">=</span> <span class="n">changedIDs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                    <span class="n">changedIDs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">idComToKeep</span>

                    <span class="c1">#print(timeEnd,idComToChange,idComToKeep)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_change_com_id</span><span class="p">(</span><span class="n">timeEnd</span><span class="p">,</span><span class="n">idComToChange</span><span class="p">,</span><span class="n">idComToKeep</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">typedEvents</span><span class="p">:</span>
            <span class="c1">#if events are not typed, we infer what we can, i.e one input and one output is a continue, otherwise we change label of edges accordingly</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">:</span>
                <span class="n">coms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">cID</span><span class="p">,</span><span class="n">nodes</span><span class="p">)</span> <span class="ow">in</span> <span class="n">coms</span><span class="p">:</span>
                    <span class="n">node_current</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">cID</span><span class="p">)</span>

                    <span class="n">succ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">out_degree</span><span class="p">([</span><span class="n">node_current</span><span class="p">])</span>

                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_current</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">frozenset</span><span class="p">):</span> <span class="c1"># If there are communities in the previous steps that consider this one similar</span>
                        <span class="n">com_predecessors</span> <span class="o">=</span> <span class="n">node_current</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#node_current[1] contains the list of similar predecessors, instead of a single ID</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">com_predecessors</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">main_pred</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">com_predecessors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">main_pred</span><span class="p">][</span><span class="n">node_current</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;continue&quot;</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">main_pred_match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                            <span class="n">main_pred</span> <span class="o">=</span> <span class="kc">None</span>
                            <span class="k">for</span> <span class="n">merged</span> <span class="ow">in</span> <span class="n">com_predecessors</span><span class="p">:</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">merged</span><span class="p">][</span><span class="n">node_current</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;merge&quot;</span>
                                 <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">merged</span><span class="p">][</span><span class="n">node_current</span><span class="p">][</span><span class="s2">&quot;fraction&quot;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">main_pred_match</span><span class="p">:</span>
                                    <span class="n">main_pred_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">merged</span><span class="p">][</span><span class="n">node_current</span><span class="p">][</span><span class="s2">&quot;fraction&quot;</span><span class="p">]</span>
                                    <span class="n">main_pred</span> <span class="o">=</span> <span class="n">merged</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">_change_com_id</span><span class="p">(</span><span class="n">node_current</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node_current</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">main_pred</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">node_current</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_current</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">main_pred</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


                    <span class="c1">#If there is at least one similar community in the next step</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">succ</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">succ</span><span class="p">[</span><span class="n">node_current</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">main_succ_match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">main_succ</span> <span class="o">=</span> <span class="kc">None</span>

                        <span class="c1">#Find the most similar community in next step (main_succ)</span>
                        <span class="k">for</span> <span class="n">splitted</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node_current</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">node_current</span><span class="p">][</span><span class="n">splitted</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;split&quot;</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">node_current</span><span class="p">][</span><span class="n">splitted</span><span class="p">][</span><span class="s2">&quot;fraction&quot;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">main_succ_match</span><span class="p">:</span>
                                <span class="n">main_succ_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">node_current</span><span class="p">][</span><span class="n">splitted</span><span class="p">][</span><span class="s2">&quot;fraction&quot;</span><span class="p">]</span>
                                <span class="n">main_succ</span> <span class="o">=</span> <span class="n">splitted</span>


                        <span class="c1">#Register to the main successor that this community wants to give it its ID.</span>
                        <span class="n">candidates_names</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">main_succ</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">frozenset</span><span class="p">):</span>
                            <span class="n">candidates_names</span><span class="o">+=</span><span class="nb">list</span><span class="p">(</span><span class="n">main_succ</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">candidates_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_current</span><span class="p">)</span>
                        <span class="n">candidates_names</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">candidates_names</span><span class="p">)</span>


                        <span class="bp">self</span><span class="o">.</span><span class="n">_change_com_id</span><span class="p">(</span><span class="n">main_succ</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">main_succ</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">candidates_names</span><span class="p">)</span>




    <span class="k">def</span> <span class="nf">_to_DynCommunitiesIG_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Work only in the standard represntation: all sn have duration 1, no missing snapshot</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dyn_com_local</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">nodes</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="nb">id</span>
                    <span class="n">dyn_com_local</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">name</span><span class="p">,{})</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">n</span><span class="p">,[])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dyn_com_local</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">n</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dyn_com_local</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                        <span class="n">dyn_com_local</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dyn_com_local</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dyn_com_local</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">to_return_com</span> <span class="o">=</span> <span class="n">tn</span><span class="o">.</span><span class="n">DynCommunitiesIG</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dyn_com_local</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">dyn_com_local</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="n">dyn_com_local</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">Intervals</span><span class="p">(</span><span class="n">dyn_com_local</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">n</span><span class="p">])</span>

        <span class="n">to_return_com</span><span class="o">.</span><span class="n">fast_set_affiliations</span><span class="p">(</span><span class="n">dyn_com_local</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_return_com</span>

<div class="viewcode-block" id="DynCommunitiesSN.to_DynCommunitiesIG"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.to_DynCommunitiesIG.html#tnetwork.DynCommunitiesSN.to_DynCommunitiesIG">[docs]</a>    <span class="k">def</span> <span class="nf">to_DynCommunitiesIG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sn_duration</span><span class="p">,</span> <span class="n">convertTimeToInteger</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to SG snapshot_affiliations</span>
<span class="sd">        :param sn_duration: time of a snapshot, or None for automatic: each snapshot last until start of the next</span>
<span class="sd">        :param convertTimeToInteger: if True, snapshot_affiliations IDs will be forgottent and replaced by consecutive integers</span>
<span class="sd">        :return: DynamicCommunitiesIG</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dynComTN</span><span class="o">=</span> <span class="n">tn</span><span class="o">.</span><span class="n">DynCommunitiesIG</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">convertTimeToInteger</span><span class="p">:</span>
                <span class="n">t</span><span class="o">=</span><span class="n">i</span>
                <span class="n">tNext</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="o">.</span><span class="n">peekitem</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">sn_duration</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tNext</span> <span class="o">=</span> <span class="n">current_t</span> <span class="o">+</span> <span class="n">sn_duration</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">tNext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="o">.</span><span class="n">peekitem</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># computing the min duration to choose as duration of the last period</span>
                        <span class="n">dates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                        <span class="n">minDuration</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">dates</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>
                        <span class="n">tNext</span> <span class="o">=</span> <span class="n">current_t</span> <span class="o">+</span> <span class="n">minDuration</span>


            <span class="k">for</span> <span class="p">(</span><span class="n">cID</span><span class="p">,</span><span class="n">nodes</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="o">.</span><span class="n">peekitem</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="c1">#for each community for this timestep</span>
                <span class="n">dynComTN</span><span class="o">.</span><span class="n">add_affiliation</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">cID</span><span class="p">,</span><span class="n">Intervals</span><span class="p">((</span><span class="n">current_t</span><span class="p">,</span><span class="n">tNext</span><span class="p">)))</span>


        <span class="c1">#convert also events</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">!=</span><span class="s2">&quot;continue&quot;</span><span class="p">:</span> <span class="c1">#if snapshot_affiliations have different IDs</span>
                <span class="n">dynComTN</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">add_event</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dynComTN</span></div>


    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        reseampling a dynamic community at higher frequency</span>

<span class="sd">        :param bin_size: desired size of bins, in the internal time unit (not necessarily equals to the number of snapshot_affiliations)</span>
<span class="sd">        :param t_start: time step to start the binning (default: first)</span>
<span class="sd">        :param t_end: time step (not included) to stop the binning (default: last)</span>
<span class="sd">        :return: a DynCommunitiesSN object</span>
<span class="sd">        &quot;&quot;&quot;</span>



        <span class="k">if</span> <span class="n">t_start</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">t_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">t_end</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">t_end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">bin_size</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_size</span><span class="o">=</span><span class="n">t_end</span><span class="o">-</span><span class="n">t_start</span>


        <span class="n">bins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">):</span>
            <span class="n">bins</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">bin_size</span><span class="p">))</span>

        <span class="n">toReturn</span> <span class="o">=</span> <span class="n">DynCommunitiesSN</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">binStart</span><span class="p">,</span><span class="n">binEnd</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">()</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">binStart</span><span class="p">)</span>
            <span class="n">toReturn</span><span class="o">.</span><span class="n">add_snapshot</span><span class="p">(</span><span class="n">binStart</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">toReturn</span>




    <span class="k">def</span> <span class="nf">communities_duration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">to_return</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">all_coms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">communities_sn_by_sn</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">com_ID</span><span class="p">,</span> <span class="n">evol</span> <span class="ow">in</span> <span class="n">all_coms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">to_return</span><span class="p">[</span><span class="n">com_ID</span><span class="p">]</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">evol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_return</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Remy Cazabet

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>