

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tnetwork.dyn_community.communities_dyn_sn &mdash; tnetwork  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> tnetwork
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installing.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/from_notebooks/demo_intro/demo_intro.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation.html">Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">tnetwork</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>tnetwork.dyn_community.communities_dyn_sn</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tnetwork.dyn_community.communities_dyn_sn</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">sortedcontainers</span>
<span class="kn">from</span> <span class="nn">tnetwork.dyn_community.communitiesEventsHandler</span> <span class="kn">import</span> <span class="n">CommunitiesEvent</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">tnetwork</span> <span class="k">as</span> <span class="nn">tn</span>
<span class="c1">#from tnetwork.utils import bidict #### do not use bidict to avoid having to use frozenset</span>
<span class="kn">from</span> <span class="nn">tnetwork.utils.community_utils</span> <span class="kn">import</span> <span class="n">nodesets2affiliations</span>
<span class="kn">from</span> <span class="nn">tnetwork.utils.community_utils</span> <span class="kn">import</span> <span class="n">jaccard</span>
<span class="kn">from</span> <span class="nn">tnetwork.utils.intervals</span> <span class="kn">import</span> <span class="n">Intervals</span>
<span class="kn">from</span> <span class="nn">tnetwork.dyn_community.communities_dyn</span> <span class="kn">import</span> <span class="n">DynCommunities</span>


<div class="viewcode-block" id="DynCommunitiesSN"><a class="viewcode-back" href="../../../reference/dyn_communities.html#tnetwork.DynCommunitiesSN">[docs]</a><span class="k">class</span> <span class="nc">DynCommunitiesSN</span><span class="p">(</span><span class="n">DynCommunities</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dynamic communities as sequences of snapshots</span>

<span class="sd">    Communities are represented as a SortedDict, key:time, value: dict id:{set of nodes}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">snapshots</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization</span>

<span class="sd">        Initialize a dynamic community object, corresponding to a snapshot-based dynamic network</span>

<span class="sd">        :param snapshots: list of snapshots timestep to create, initially empty</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="o">=</span><span class="n">sortedcontainers</span><span class="o">.</span><span class="n">SortedDict</span><span class="p">()</span> <span class="c1">#sorteddict t:{id:{set of nodes}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">CommunitiesEvent</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_automaticID</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">snapshots</span><span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">snapshots</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_empty_snapshot</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_empty_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>

    <span class="k">def</span> <span class="nf">remove_communities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">communities</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">com</span> <span class="ow">in</span> <span class="n">communities</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">com</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">time</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">time</span><span class="p">][</span><span class="n">com</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keep only the selected period</span>

<span class="sd">        :param start:</span>
<span class="sd">        :param end:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">to_return</span> <span class="o">=</span> <span class="n">tn</span><span class="o">.</span><span class="n">DynCommunitiesSN</span><span class="p">()</span>
        <span class="n">interv</span> <span class="o">=</span> <span class="n">tn</span><span class="o">.</span><span class="n">Intervals</span><span class="p">((</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">interv</span><span class="p">:</span>
                <span class="n">to_return</span><span class="o">.</span><span class="n">set_communities</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_return</span>


<div class="viewcode-block" id="DynCommunitiesSN.snapshot_communities"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.snapshot_communities.html#tnetwork.DynCommunitiesSN.snapshot_communities">[docs]</a>    <span class="k">def</span> <span class="nf">snapshot_communities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Affiliations by communities</span>

<span class="sd">        If t is given, return communities at this t as a bidict id:{set of nodes}</span>
<span class="sd">        else, return a sorted dict, key:time, value: dict id:{set of nodes}</span>

<span class="sd">        :param t: time</span>
<span class="sd">        :return: a dict id:{set of nodes}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">communities_sn_by_sn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Communities snapshots by snapshots</span>

<span class="sd">        Return for each community its nodes snaphsot by snapshot</span>
<span class="sd">        :return: a dict c:{SortedDict{t:{set of nodes}}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_return</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cID</span><span class="p">,</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">to_return</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cID</span><span class="p">,</span><span class="n">sortedcontainers</span><span class="o">.</span><span class="n">SortedDict</span><span class="p">())</span>
                <span class="n">to_return</span><span class="p">[</span><span class="n">cID</span><span class="p">][</span><span class="n">time</span><span class="p">]</span><span class="o">=</span><span class="n">nodes</span>
        <span class="k">return</span> <span class="n">to_return</span>

<div class="viewcode-block" id="DynCommunitiesSN.communities"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.communities.html#tnetwork.DynCommunitiesSN.communities">[docs]</a>    <span class="k">def</span> <span class="nf">communities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Communities</span>

<span class="sd">        If t is given, return communities at this t as a dict, key=node, value=set of communities</span>
<span class="sd">        else, return a dict, key:node, value: dict community:list of times</span>

<span class="sd">        :param t: time</span>
<span class="sd">        :return: dictionary, key=node, value=dict community:list of times or if t is not None: dict community:list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">to_return</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">cID</span><span class="p">,</span><span class="n">nodes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                        <span class="n">to_return</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cID</span><span class="p">,{})</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="n">cID</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">n</span><span class="p">,[])</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="n">cID</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">to_return</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span></div>

<div class="viewcode-block" id="DynCommunitiesSN.affiliations"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.affiliations.html#tnetwork.DynCommunitiesSN.affiliations">[docs]</a>    <span class="k">def</span> <span class="nf">affiliations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Affiliations by nodes</span>

<span class="sd">        If t is given, return affiliation at this t as a dict, key=node, value=set of communities</span>
<span class="sd">        else, return a dict, key:node, value: dict community:list of times</span>

<span class="sd">        :param t: time</span>
<span class="sd">        :return: dictionary, key=node, value=dict community:list of times or if t is not None: dict community:list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">to_return</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">cID</span><span class="p">,</span><span class="n">nodes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                        <span class="n">to_return</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">n</span><span class="p">,{})</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cID</span><span class="p">,[])</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">cID</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">to_return</span>


        <span class="k">return</span> <span class="n">nodesets2affiliations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()[</span><span class="n">t</span><span class="p">])</span></div>


<div class="viewcode-block" id="DynCommunitiesSN.affiliations_durations"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.affiliations_durations.html#tnetwork.DynCommunitiesSN.affiliations_durations">[docs]</a>    <span class="k">def</span> <span class="nf">affiliations_durations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">communities</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Duration of affiliations</span>

<span class="sd">        Return the duration in each community (for non-zero values) for the provided nodes and the provided communities (default: all)</span>
<span class="sd">        return set of triplets (n,c,duration), or set of pairs of one if the parameters has a single value, or a single value if single node and single com</span>

<span class="sd">        :param nodes: node(s) for which we want durations. single node or set of nodes</span>
<span class="sd">        :param communities: communities(s) for which we want durations. single community or set of communities</span>
<span class="sd">        :return: set of triplets (n,c,duration), or set of pairs of one if the parameters has a single value, or a single value if single node and single com</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">toReturn</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">aff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affiliations</span><span class="p">()</span>
        <span class="n">coms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">communities</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nodes</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">aff</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">communities</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">communities</span><span class="o">=</span><span class="n">coms</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="n">nodes</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">communities</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="n">communities</span><span class="o">=</span><span class="p">[</span><span class="n">communities</span><span class="p">]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">communities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">communities</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">communities</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">aff</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">toReturn</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">)]</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">aff</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">c</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">communities</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">toReturn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">toReturn</span><span class="o">.</span><span class="n">items</span><span class="p">())[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">toReturn</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span><span class="n">t</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">),</span><span class="n">t</span> <span class="ow">in</span> <span class="n">toReturn</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">communities</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">toReturn</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span><span class="n">t</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="p">),</span><span class="n">t</span> <span class="ow">in</span> <span class="n">toReturn</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">return</span> <span class="n">toReturn</span></div>

<div class="viewcode-block" id="DynCommunitiesSN.snapshot_affiliations"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.snapshot_affiliations.html#tnetwork.DynCommunitiesSN.snapshot_affiliations">[docs]</a>    <span class="k">def</span> <span class="nf">snapshot_affiliations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Affiliations by snapshots</span>

<span class="sd">        If t is given, return affiliation at this t as a dict, key=node, value=set of communities</span>
<span class="sd">        else, return a sorted dict, key:time, value: dict node:communities</span>

<span class="sd">        :param t: time</span>
<span class="sd">        :return: sorted dict, key:time, value: dict node:communities or key=node, value=set of communities</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sortedcontainers</span><span class="o">.</span><span class="n">SortedDict</span><span class="p">({</span><span class="n">k</span><span class="p">:</span><span class="n">nodesets2affiliations</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">nodesets2affiliations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()[</span><span class="n">t</span><span class="p">])</span></div>

<div class="viewcode-block" id="DynCommunitiesSN.add_affiliation"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.add_affiliation.html#tnetwork.DynCommunitiesSN.add_affiliation">[docs]</a>    <span class="k">def</span> <span class="nf">add_affiliation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">cIDs</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Affiliate node(s) to community(ies) at time(s)</span>

<span class="sd">        Add belonging for the provided node(s) to the provided communitie(s) at the provided time(s).</span>
<span class="sd">        (all nodes, at all times, in all communities)</span>
<span class="sd">        If communities do not exist, they are created.</span>

<span class="sd">        :param nodes: accept set/list of nodes or single node</span>
<span class="sd">        :param times: accept list of times or single time</span>
<span class="sd">        :param cIDs: accept lists of coms or single com</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">times</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">times</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cIDs</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cIDs</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">cIDs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">cIDs</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">nodes</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">nodes</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>



        <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">ts</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
            <span class="n">coms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">ts</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">cIDs</span><span class="p">:</span>
                <span class="n">cs</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">coms</span><span class="p">:</span>
                    <span class="n">coms</span><span class="p">[</span><span class="n">cs</span><span class="p">]</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>
                <span class="n">coms</span><span class="p">[</span><span class="n">cs</span><span class="p">]</span><span class="o">=</span><span class="n">coms</span><span class="p">[</span><span class="n">cs</span><span class="p">]</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="DynCommunitiesSN.set_communities"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.set_communities.html#tnetwork.DynCommunitiesSN.set_communities">[docs]</a>    <span class="k">def</span> <span class="nf">set_communities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">communities</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Affiliate nodes given a dictionary representation</span>

<span class="sd">        Given a clustering provided as a dict  id:{set of nodes} , set this clustering at the</span>
<span class="sd">        provided time (replace any existing clustering at that time)</span>

<span class="sd">        :param t: a time instant</span>
<span class="sd">        :param communities: communitie as  dict  id:{set of nodes}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">communities</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">communities</span></div>

<div class="viewcode-block" id="DynCommunitiesSN.add_community"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.add_community.html#tnetwork.DynCommunitiesSN.add_community">[docs]</a>    <span class="k">def</span> <span class="nf">add_community</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a community at a time</span>

<span class="sd">        Create a community at time t with the provided nodes and id  ( random id if not provided)</span>

<span class="sd">        :param t: time</span>
<span class="sd">        :param nodes: a community provided as a set/list of nodes</span>
<span class="sd">        :param id: optional id, otherwise, new unique one</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">id</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="nb">id</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_automaticID</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_automaticID</span><span class="o">+=</span><span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_affiliation</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">id</span></div>

    <span class="k">def</span> <span class="nf">_com_ID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the id of a community at a time</span>
<span class="sd">        </span>
<span class="sd">        given a set of nodes composing a community, return the id of this community. If there is not one and only </span>
<span class="sd">        one community containing those nodes, raise an exception</span>

<span class="sd">        :param t: time</span>
<span class="sd">        :param nodes: set of nodes</span>
<span class="sd">        :return: ID of the community. If several matching, raise exceptions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_return</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">com_nodes</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">com_nodes</span><span class="o">==</span><span class="n">nodes</span><span class="p">:</span>
                <span class="n">to_return</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_return</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;no community found&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_return</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;several matching communities found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_return</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>



    <span class="k">def</span> <span class="nf">_compute_fraction_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">com1</span><span class="p">,</span> <span class="n">com2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        compute a fraction of identity between two communities</span>

<span class="sd">        :param com1: a com</span>
<span class="sd">        :param com2: another com</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">common</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">com1</span> <span class="o">&amp;</span> <span class="n">com2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">common</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">com1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">common</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">com2</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">create_standard_event_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keepingPreviousEvents</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span><span class="n">score</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From a set of static communities, do a standard matching process such as all communities in consecutive steps with at least a node in common are linked by an event, and compute a similarity score</span>

<span class="sd">        :param keepingPreviousEvents: if true, if events were already present, we keep them and compute their score</span>
<span class="sd">        :param threshold: a minimal value of score under which a link is not created. Default: 0</span>
<span class="sd">        :param score: a function describing how to compute the score. Takes 2 communities as input and return the score.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">score</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">jaccard</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keepingPreviousEvents</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">=</span><span class="n">CommunitiesEvent</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">communities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()</span>
            <span class="k">for</span> <span class="p">((</span><span class="n">t1</span><span class="p">,</span><span class="n">com1</span><span class="p">),(</span><span class="n">t2</span><span class="p">,</span><span class="n">com2</span><span class="p">))</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                <span class="n">fraction</span> <span class="o">=</span> <span class="n">score</span><span class="p">(</span><span class="n">communities</span><span class="p">[</span><span class="n">t1</span><span class="p">][</span><span class="n">com1</span><span class="p">],</span> <span class="n">communities</span><span class="p">[</span><span class="n">t2</span><span class="p">][</span><span class="n">com2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[(</span><span class="n">t1</span><span class="p">,</span> <span class="n">com1</span><span class="p">)][(</span><span class="n">t2</span><span class="p">,</span> <span class="n">com2</span><span class="p">)][</span><span class="s2">&quot;fraction&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">fraction</span>

        <span class="c1">#compute events between consecutive communities</span>
        <span class="n">communities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">communities</span><span class="p">),</span><span class="mi">1</span><span class="p">):</span>
            <span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">comsBefore</span><span class="p">)</span> <span class="o">=</span> <span class="n">communities</span><span class="o">.</span><span class="n">peekitem</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">(</span><span class="n">t2</span><span class="p">,</span><span class="n">comsPresent</span><span class="p">)</span> <span class="o">=</span> <span class="n">communities</span><span class="o">.</span><span class="n">peekitem</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">comID</span><span class="p">,</span><span class="n">comNodes</span> <span class="ow">in</span> <span class="n">comsBefore</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">com2ID</span><span class="p">,</span><span class="n">com2Nodes</span> <span class="ow">in</span> <span class="n">comsPresent</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">fraction</span> <span class="o">=</span> <span class="n">score</span><span class="p">(</span><span class="n">comNodes</span><span class="p">,</span> <span class="n">com2Nodes</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">fraction</span><span class="o">&gt;</span><span class="n">threshold</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">add_event</span><span class="p">((</span><span class="n">t1</span><span class="p">,</span> <span class="n">comID</span><span class="p">),</span> <span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">com2ID</span><span class="p">),</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s2">&quot;unknown&quot;</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="n">fraction</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_change_com_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">oldID</span><span class="p">,</span><span class="n">newID</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify the ID of a community, in the community list and the event graph</span>

<span class="sd">        :param t:</span>
<span class="sd">        :param nodes:</span>
<span class="sd">        :param newID:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nodesOfCom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">oldID</span><span class="p">]</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">oldID</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">newID</span><span class="p">]</span><span class="o">=</span><span class="n">nodesOfCom</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">oldID</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">,</span> <span class="p">{(</span><span class="n">t</span><span class="p">,</span><span class="n">oldID</span><span class="p">):</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">newID</span><span class="p">)},</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_relabel_communities_to_avoid_conflict_between_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_change_com_id</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="nb">id</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_relabel_coms_from_continue_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typedEvents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        If an event graph is present, rename the communities such as two communities that are linked by an event labeled &quot;continue&quot; will have the same ID.</span>
<span class="sd">        If events are not labeled, is possible to label them automatically into merge, split and continue using the in/out degrees of nodes in the event graph</span>

<span class="sd">        Be careful that if your communities in different snapshots already have similar names, it can add confusion</span>
<span class="sd">        :param typedEvents: True if continue labels have already been set.</span>
<span class="sd">        :param rename: True if all communities are renamed. This is useful if, before calling this function, two communities in different steps could have the same name, and we do not want to keep this information</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">rename</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_relabel_communities_to_avoid_conflict_between_steps</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">typedEvents</span><span class="p">:</span>
            <span class="n">changedIDs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;continue&quot;</span><span class="p">:</span>

                    <span class="c1">#update com ID in self</span>
                    <span class="n">timeEnd</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">idComToChange</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">idComToKeep</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">changedIDs</span><span class="p">:</span>
                        <span class="n">idComToKeep</span> <span class="o">=</span> <span class="n">changedIDs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                    <span class="n">changedIDs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">idComToKeep</span>

                    <span class="c1">#print(timeEnd,idComToChange,idComToKeep)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_change_com_id</span><span class="p">(</span><span class="n">timeEnd</span><span class="p">,</span><span class="n">idComToChange</span><span class="p">,</span><span class="n">idComToKeep</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">typedEvents</span><span class="p">:</span>
            <span class="c1">#if events are not typed, we infer what we can, i.e one input and one output is a continue, otherwise we change label of edges accordingly</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">:</span>
                <span class="n">coms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">cID</span><span class="p">,</span><span class="n">nodes</span><span class="p">)</span> <span class="ow">in</span> <span class="n">coms</span><span class="p">:</span>
                    <span class="n">node_current</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">cID</span><span class="p">)</span>

                    <span class="n">succ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">out_degree</span><span class="p">([</span><span class="n">node_current</span><span class="p">])</span>

                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_current</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">frozenset</span><span class="p">):</span> <span class="c1"># If there are communities in the previous steps that consider this one similar</span>
                        <span class="n">com_predecessors</span> <span class="o">=</span> <span class="n">node_current</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#node_current[1] contains the list of similar predecessors, instead of a single ID</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">com_predecessors</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">main_pred</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">com_predecessors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">main_pred</span><span class="p">][</span><span class="n">node_current</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;continue&quot;</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">main_pred_match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                            <span class="n">main_pred</span> <span class="o">=</span> <span class="kc">None</span>
                            <span class="k">for</span> <span class="n">merged</span> <span class="ow">in</span> <span class="n">com_predecessors</span><span class="p">:</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">merged</span><span class="p">][</span><span class="n">node_current</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;merge&quot;</span>
                                 <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">merged</span><span class="p">][</span><span class="n">node_current</span><span class="p">][</span><span class="s2">&quot;fraction&quot;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">main_pred_match</span><span class="p">:</span>
                                    <span class="n">main_pred_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">merged</span><span class="p">][</span><span class="n">node_current</span><span class="p">][</span><span class="s2">&quot;fraction&quot;</span><span class="p">]</span>
                                    <span class="n">main_pred</span> <span class="o">=</span> <span class="n">merged</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">_change_com_id</span><span class="p">(</span><span class="n">node_current</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node_current</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">main_pred</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">node_current</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_current</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">main_pred</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


                    <span class="c1">#If there is at least one similar community in the next step</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">succ</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">succ</span><span class="p">[</span><span class="n">node_current</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">main_succ_match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">main_succ</span> <span class="o">=</span> <span class="kc">None</span>

                        <span class="c1">#Find the most similar community in next step (main_succ)</span>
                        <span class="k">for</span> <span class="n">splitted</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">node_current</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">node_current</span><span class="p">][</span><span class="n">splitted</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;split&quot;</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">node_current</span><span class="p">][</span><span class="n">splitted</span><span class="p">][</span><span class="s2">&quot;fraction&quot;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">main_succ_match</span><span class="p">:</span>
                                <span class="n">main_succ_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">node_current</span><span class="p">][</span><span class="n">splitted</span><span class="p">][</span><span class="s2">&quot;fraction&quot;</span><span class="p">]</span>
                                <span class="n">main_succ</span> <span class="o">=</span> <span class="n">splitted</span>


                        <span class="c1">#Register to the main successor that this community wants to give it its ID.</span>
                        <span class="n">candidates_names</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">main_succ</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">frozenset</span><span class="p">):</span>
                            <span class="n">candidates_names</span><span class="o">+=</span><span class="nb">list</span><span class="p">(</span><span class="n">main_succ</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">candidates_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_current</span><span class="p">)</span>
                        <span class="n">candidates_names</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">candidates_names</span><span class="p">)</span>


                        <span class="bp">self</span><span class="o">.</span><span class="n">_change_com_id</span><span class="p">(</span><span class="n">main_succ</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">main_succ</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">candidates_names</span><span class="p">)</span>




    <span class="k">def</span> <span class="nf">_to_DynCommunitiesIG_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Work only in the standard represntation: all sn have duration 1, no missing snapshot</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dyn_com_local</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_communities</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">nodes</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="nb">id</span>
                    <span class="n">dyn_com_local</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">name</span><span class="p">,{})</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">n</span><span class="p">,[])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dyn_com_local</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">n</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dyn_com_local</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                        <span class="n">dyn_com_local</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dyn_com_local</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dyn_com_local</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">to_return_com</span> <span class="o">=</span> <span class="n">tn</span><span class="o">.</span><span class="n">DynCommunitiesIG</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dyn_com_local</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">dyn_com_local</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="n">dyn_com_local</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">Intervals</span><span class="p">(</span><span class="n">dyn_com_local</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">n</span><span class="p">])</span>

        <span class="n">to_return_com</span><span class="o">.</span><span class="n">_fast_set_affiliations</span><span class="p">(</span><span class="n">dyn_com_local</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_return_com</span>

<div class="viewcode-block" id="DynCommunitiesSN.to_DynCommunitiesIG"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.to_DynCommunitiesIG.html#tnetwork.DynCommunitiesSN.to_DynCommunitiesIG">[docs]</a>    <span class="k">def</span> <span class="nf">to_DynCommunitiesIG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sn_duration</span><span class="p">,</span> <span class="n">convertTimeToInteger</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to SG communities</span>

<span class="sd">        :param sn_duration: time of a snapshot, or None for automatic: each snapshot last until start of the next</span>
<span class="sd">        :param convertTimeToInteger: if True, communities IDs will be forgottent and replaced by consecutive integers</span>
<span class="sd">        :return: DynamicCommunitiesIG</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dynComTN</span><span class="o">=</span> <span class="n">tn</span><span class="o">.</span><span class="n">DynCommunitiesIG</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">convertTimeToInteger</span><span class="p">:</span>
                <span class="n">t</span><span class="o">=</span><span class="n">i</span>
                <span class="n">tNext</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="o">.</span><span class="n">peekitem</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">sn_duration</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tNext</span> <span class="o">=</span> <span class="n">current_t</span> <span class="o">+</span> <span class="n">sn_duration</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">tNext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="o">.</span><span class="n">peekitem</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># computing the min duration to choose as duration of the last period</span>
                        <span class="n">dates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                        <span class="n">minDuration</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">dates</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>
                        <span class="n">tNext</span> <span class="o">=</span> <span class="n">current_t</span> <span class="o">+</span> <span class="n">minDuration</span>


            <span class="k">for</span> <span class="p">(</span><span class="n">cID</span><span class="p">,</span><span class="n">nodes</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="o">.</span><span class="n">peekitem</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="c1">#for each community for this timestep</span>
                <span class="n">dynComTN</span><span class="o">.</span><span class="n">add_affiliation</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">cID</span><span class="p">,</span><span class="n">Intervals</span><span class="p">((</span><span class="n">current_t</span><span class="p">,</span><span class="n">tNext</span><span class="p">)))</span>


        <span class="c1">#convert also events</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">!=</span><span class="s2">&quot;continue&quot;</span><span class="p">:</span> <span class="c1">#if communities have different IDs</span>
                <span class="n">dynComTN</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">add_event</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dynComTN</span></div>


    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        reseampling a dynamic community at higher frequency</span>

<span class="sd">        :param bin_size: desired size of bins, in the internal time unit</span>
<span class="sd">        :param t_start: time step to start the binning (default: first)</span>
<span class="sd">        :param t_end: time step (not included) to stop the binning (default: last)</span>
<span class="sd">        :return: a DynCommunitiesSN object</span>
<span class="sd">        &quot;&quot;&quot;</span>



        <span class="k">if</span> <span class="n">t_start</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">t_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">t_end</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">t_end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">bin_size</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_size</span><span class="o">=</span><span class="n">t_end</span><span class="o">-</span><span class="n">t_start</span>


        <span class="n">bins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">):</span>
            <span class="n">bins</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">bin_size</span><span class="p">))</span>

        <span class="n">toReturn</span> <span class="o">=</span> <span class="n">DynCommunitiesSN</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">binStart</span><span class="p">,</span><span class="n">binEnd</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">()</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">binStart</span><span class="p">)</span>
            <span class="n">toReturn</span><span class="o">.</span><span class="n">add_snapshot</span><span class="p">(</span><span class="n">binStart</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">toReturn</span>




<div class="viewcode-block" id="DynCommunitiesSN.communities_duration"><a class="viewcode-back" href="../../../reference/generated/tnetwork.DynCommunitiesSN.communities_duration.html#tnetwork.DynCommunitiesSN.communities_duration">[docs]</a>    <span class="k">def</span> <span class="nf">communities_duration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Duration of each community</span>

<span class="sd">        :return:  {id:duration}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_return</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">all_coms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">communities_sn_by_sn</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">com_ID</span><span class="p">,</span> <span class="n">evol</span> <span class="ow">in</span> <span class="n">all_coms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">to_return</span><span class="p">[</span><span class="n">com_ID</span><span class="p">]</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">evol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_return</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Remy Cazabet

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>